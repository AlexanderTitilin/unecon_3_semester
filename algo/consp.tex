\documentclass[14pt]{extarticle}
\usepackage{fontspec}
\usepackage[russian, english]{babel}
\setmainfont{Times New Roman}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{graphicx}
\onehalfspacing
\usepackage{amsmath}
\usepackage{listings}
\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}
\usepackage[right=10mm,left=30mm,top=20mm,bottom=20mm]{geometry}
\newtheorem{theorem}{Теорема}
\newtheorem{definition}{Определение}
\newtheorem{example}{Пример}[definition] \newtheorem{corollary}{Следствие}[theorem] \newtheorem{exmp}{Пример}[theorem]
\newtheorem{lemma}[theorem]{Лемма}
\title{Вопросы к зачоту по структурам}
\author{}
\date{}
\begin{document}
    \maketitle
    \section{Асимптотические оценки времени работы алгоритмов и их смысл}
    Пусть $f,g$ функции принимающие только положитльные значения
    \begin{definition}[Тета]
        $f = \Theta(g) : \exists c_1,c_2 > 0  n_0 : \forall  n > n_0 ~ c_1 g(n) \le f(n) \le  c_2 g(n)$ 
    \end{definition}
    \begin{example}
        \[
        \frac{n^2}{2} - 3n = \Theta(n^2)
        .\] 
        Чтоб доказать нужно найти нужные константы
        \[
        c_1 n^2 \le  \frac{n^2}{2} - 3n \le c_2 n^2
        .\] 
        \[
        c_1 < \frac{1}{2} - \frac{3}{n} \le  c_2 
        .\] 
        \[
        c_1 = 1/4
        .\] 
        \[
        c_2 = 1/2
        .\] 
        при $n \ge  12$
    \end{example}
    \begin{example}
        \[
        c_1 2^{n} \le 2^{n + 1} \le  c_2 2^{n}
        .\] 
        \[
        c_1 \le  2 \le  c_2
        .\] 
    \end{example}
    \begin{definition}[O]
        \[
        f = O(g) : \exists  c ~n_0 \forall  n > n_0: f(n) \le  c g(n)
        .\] 
    \end{definition}
    \begin{definition}[Омега]
        \[
        f =  \Omega(n) : \exists  c, n_0 \forall  n > n_0 f(n) \ge  cg(n)
        .\] 
    \end{definition}
    \begin{definition}[o-малое]
        \[
        f = o(g) : \lim_{n \to \infty} \frac{f(n)}{g(n)} = 0
        .\] 
    \end{definition}
    \section{Теорема о рекурсии}
    Есть рекурсивный алгоритм. Его время работы зависит от параметра n (размера входных данных)
    \begin{enumerate}
        \item Если $n < k, k = const$ решаем задачу нерекурсивно относительно n
        \item иначе разбиваем задачу на  $a$ подзадач размера  $\frac{n}{b}$ каждую решаем рекрсувно
    \end{enumerate}
    Время работы такого алгоритма описываем такой формулой
    \[
    T(n) = 
    \begin{cases}
        g(n), n < k\\
        a * T(\frac{n}{b}) + f(n), n\ge  k
    \end{cases}
    .\] 
    $g(n)$ время для нерекурсивного решения ,  $f(n)$ время для определения подзадач и собирания результатов рекурсивных вызовов
     \begin{theorem}
        Пусть время работы рекурсивного алгоритма выражается формулой
        \[
        T(n) = aT(\frac{n}{b}) + f(n)
        .\] 
        \begin{enumerate}
            \item Если $f(n) = O(n^{c}), c< \log_{b}{a}$ то $T(n) = \Theta(n^{\log_{b}a})$
            \item Если $f(n) = \Theta(n^{c} (\log_{b}a)^{k}$ для $k\ge 0, c= \log_{b}a$, то $T(n) =\Theta(n^{c} (\log{n})^{k+1})$
             \item $f(n) = \Omega(n^{c}) c > \log_{b}a$, то $T(n) = \Theta(f(n))$ 
                 для это еще должно быть
                 \[
                 a f(\frac{n}{b}) < k f(n) ~ k < 1
                 .\] 
        \end{enumerate}
        Частный случай при $a = b$
         \[
        T(n) = a T(\frac{n}{a}) + f(n)
        .\] 
        \begin{enumerate}
            \item Если $f(n) = O(n^{c}) ,c<1$ то $T(n) = \Theta(n)$
            \item Если  $f(n) =  \Theta(n)$ то  $T(n) = \Theta(n \log{n})$
            \item Если $f(n) = \Omega(n^{c}), c> 1$, То $T(n) = \Theta(f(n))$
        \end{enumerate}
    \end{theorem}
    \begin{exmp}
        \[
        T(n) = 9T(\frac{n}{3}) + n
        .\] 
        \[
            \log_{b}{a} = 2
        .\] 
        \[
        n = O(n) \iff T(n) = \Theta(n^{2})
        .\] 
    \end{exmp}
    \begin{exmp}
        \[
        T(n)=T (\frac{2 n}{3}) +1
        .\] 
        \[
        f(n) = 1
        .\] 
        \[
        a = 1
        .\] 
        \[
        b = \frac{3}{2}
        .\] 
        \[
            \log_{3/2} 1 = 0
        .\] 
    \end{exmp}
    \section{Сортировка слиянием}
    Оценка времени работы $T(n) = 2 T (\frac{n}{2}) + n$ 
    \[
    n = \Theta(n)
    .\] 
    По теореме $T = \Theta(\log n)$
    \section{Длинная арифметика}
    Число представляем как список $int$, каждое число меньше некого числа, которое помешается в  $int$. $a = \{a_0,a_1,\dots,a_{n-1}\}$, $\forall i < n -1~ a_{i} < b$
     \[
     a = \sum_{i = 0}^{n-1} a_i b^{i}
     .\] 
     За $b$ удобно брать большую степень 10 , например миллион. Еще удобнее брать большую степень двух как пример  $2^{31}$
     \subsection{Сложение}
     Сложение двух длинных чисел происходит точно так как в столибик. Для сложения нужно сделать $n$ элементарных операций, где  $n$ количесвто цифр самого длинного числа.
    \subsection{Деление с остатотком}
    Опять алгоритм деления в столбик
    \subsection{Умножение}
    Если умножать в столбик, придется сделать  $n^2$ элементарных операций
    \subsubsection{Алгоритм карацубы}
    Пусть есть числа $a,b$ длины  $n$,  $c$ основание системы счисления
     \[
    x = c^{n/2}
    .\] 
    \[
    a = \alpha_1 x + \alpha_2
    .\] 
    \[
    b = \beta_1 x + \beta_2
    .\] 
    \[
    ab = \alpha_1 \beta x^2 + \alpha_1 \beta_2 x + \alpha_2 \beta_1 x + \alpha_2  \beta_2 = \alpha_1 \beta_1 x^2 + (\alpha_1 \beta_2 + \alpha_2 \beta_1) x + \alpha_2 \beta_2
    .\] 
    \[
    T(n) = 4 T(n/2) + O(n)
    .\] 
    \[
    \log_{2}4 = 2
    .\] 
    \[
    T(n) = \Theta(n^2)
    .\] 
    \[
    \alpha_1 \beta_1 x^2 + (\alpha_1 \beta_2 + \alpha_2 \beta_1) x + \alpha_2 \beta_2 = \alpha_1 \beta_1 x^2 + ((\alpha_1 + \beta_1)(\alpha_2 + \beta_2) -\alpha_1 \beta_1 -\alpha_2 \beta_2) + \alpha_2 \beta_2
    .\] 
    \[
    T(n) = 3 T(\frac{n}{2}) + O(n)
    .\] 
    \section{Алгоритм рабина карпа}
    Есть строка, есть подстрока, есть хешфункция, все хеши подстрок нужной длины сранвивем с хешем искомой, если равны, сравниваем посимвольно. Для опитимизации, надо сделать хорошую хеш функцию, чтоб было малок коллизий, чтобы она например зависела от позиций.
    \section{Грамматики,Регулярные выражения}
    Можно определить язык через регулярные выражения. Рассмотрим регулярки в джаве. В джаве есть класс Pattern и класс Mathcher. Pattern содержит компилированные выражения, Mathcer ищут в тексте штуки по регулярке.

    Рассмотрим задачу, есть строка $s$, нужно проверить подходит ли под регулярку 
 \begin{lstlisting}[language=Java] 
 s.mathcher("kjdskjdsk");
\end{lstlisting} 
    такая фигня возвращает boolean
\section{Задача}
Есть две квадратные матрицы, хотим сосчитать произведение. За какое время можем сделать
Наивный алгоритм   $\Theta(n^{3})$
\subsection{Алгоритм Штрассена для умножения матриц}
Сначала рассмотрим умножение комплексных чисел
 
\[
c_1 = (a + bi )
.\] 
\[
c_2 = (c + di)
.\] 
Хотим меньше умножений
\[
A_1 = (a + b)(c - d)
.\] 
\[
A_2 = ad
.\] 
\[
A_3 = bc
.\] 
\[
    (ac - bd) = (ac + bc - ad - bd) + ad - bc = A_1 + A_2 - A_3
.\] 
\[
ad + bc = A_2 + A_3
.\] 
Мы уменшили количество умножений, за счет увеличений количеств сложений.\\
Пусть есть две вещественно значные матрицы, считаем что размер матрицы есть степень 2, если не степень, дополняем нулями.
Каждую матрицу делим на 4 квадрата
\[
A = \begin{pmatrix} 
    a & b\\
    c& d\\
\end{pmatrix} 
.\] 
\[
B = \begin{pmatrix} 
    e & g \\
    f & h\\
\end{pmatrix} 
.\] 
\[
A \times B = 
\begin{pmatrix} 
    a & b\\
    c & d\\
\end{pmatrix} 
\begin{pmatrix} 
    e & g\\
    f & h
\end{pmatrix} 
=
\begin{pmatrix} 
    ae + bf & ag + bh\\ 
    ce + df & cg + dh
\end{pmatrix} 
.\] 
Потребовалось 8 матричных умножений и $n^2$ сложений
\[
T(n) = 8 T(\frac{n}{2}) + \Theta(n^2)
.\] 
по теореме о рекурии $T(n) = \Theta(n^{3})$. Херня полная, нужно уменшить рекурсивные вызовы до 7
\[
r = ae + bg
.\] 
\[
s = ag + bh
.\] 
\[
t = ce + df
.\] 
\[
u = cg +dh
.\] 
\begin{tabular}{|c|c|c|c}
    \hline
    i & $A_{i}$ & $B_{i}$ & $P_{i} = A_{i} \times B_{i}$ \\
    \hline
    1 & a & g - h & ag - ah\\
    2 & $a+b$ & h &  $ah + bh$
\end{tabular}
Бля, лень в випедии посмотрю\\
У булевых матриц используют прикол, так как у булевых операций нет вычитания. Булевы значения меняют на $0,1$ перемножают ка числовые и ненули заменяют на true
\section{Алгоритм без полиноминального решения}
Такие алгоритмы при больших числа не имеют смысла, поэтому используют приближенный алгоритм
\subsection{Задача коммивояжера}
Есть связный граф, вершины соеденны ребрами. Есть вершина, надо пройти по всем хотя бы  один раз и вернуться в исходную. Так е все ребра имееют вес, нужен минималльны
\includegraphics{g.pdf}
Задача, решается , если в графе выполняется неравенство треугольника
\begin{enumerate}
    \item Можно пребрать все гамильтоновы циклы, очень долго и гавно вообще.
    \item Жадный алгоритм, дает рещультат не более чем в два раза хуже оптимального.
    \item Построение пути по минимальному скелету, не более чем в два раза хуже оптимального
    \item Линейное программирование, но может скатиться в полнй перебор
\end{enumerate}
\subsection{Жадный алгоритм}
Жадный алгоритм на каждом шаге пытается доавить в имеющийся цикл одну вершину, ближайшую к циклу. Этот алгоримт хорошо работает в случае полного графа
\section{Слова и алфавиты}
\[
    \text{Алфавит~} A = \{a_1,a_2,\dots,a_{n}\}
.\] 
\[
b \in A
.\] 
множество симвлов (букв)
\[
    \text{Слово~} \alpha = a_1 a_2 \dots a_{k}
.\] 
Последоватлеьность символов
\[
\mid \alpha \mid := k
.\] 
длина слова
\[
\mid \epsilon \mid := 0
.\] 
пустое слово, не содержит символов
\[
A^{k} 
.\] 
множество слов над алфавитом $A$ длины  $k$
Введем операцию котенации (конкатенации)
 \[
\alpha = a_1 a_2 \dots a_{n} \in A^{n}
.\] 
\[
\beta = b_1 b_2 \dots b_{m} \in A^{m}
.\] 
\[
\alpha \beta = a_1 a_2 \dots a_{n} b_1 b_2 \dots b_{m} \in A^{n+m}
.\] 
\[
\alpha \epsilon = \epsilon \alpha = \alpha
.\] 
\[
    A^{+} := \bigcup \limits_{i = 1}^{\infty} A^{i}
.\] 
Множество всех непустых слов над алфавитом $A$
\[
    A^{*} := \bigcup \limits_{i = 0}^{\infty} A^{i}
.\] 
Множество всех слов над алавитом $A$ 
\[
\alpha \in A^{*}, \beta \in B^{*} \alpha \beta \in (A \cup B)^{*}
.\] 
\[
    L \subset A^{*} \text{~Язык над алфавитом}
.\] 
\[
L, M \subset A^{*}
.\] 
\[
    LM = \{\alpha \beta \mid \alpha \in L , \beta \in M\}
.\] 
котенация языков
\subsection{Регуляные язык}
Рассмотрим алфавит $A = \{a,b,\dots,\}$. Регулярные выражения включают символы языка и операции объединения и котенации
 \begin{enumerate}
     \item Выражение $a \in A$ задает язык  $L = \{a\}$
    \item  $E_1$ выражение задает язык $L_1$, $E_2$ задает язык $L_2$ 
        \[
            E_1 | E_2 ,\text{задает~} L_1 \cup L_2
        .\] 
    \item $E_1 E_2$ задает $L_1 L_2$
    \item $*,+$ переносятся с выражений на языки
\end{enumerate}
\subsubsection{Примеры}
\begin{enumerate}
    \item $A = {a,b,c}, E = a(a|b|c|)*c$ задает язык, определяющй множество слов, которые начинаются на a,кончаются на с 
         \[
        A = a|b|c
        .\] 
        \[
        E = a A^{*}c
        .\]
    \item 
        \[
            \lambda = \{\epsilon\}
        .\] 
        \[
            [A] = A|\lambda
        .\] 
        \[
            A^{[k]} = \bigcup \limits_{i = 0}^{k} A^{i}
        .\] 
        \[
            A = \{0,1,2,\dots,9,+,-,E,.\}
        .\] 
        Задаем регулярку для правильных вещественных чисел
        \[
        D = 0|1|\dots|9
        .\] 
        \[
            [+|-]D^{+}[.D^{+}][E[+-]D^{+}]
        .\] 
\end{enumerate}
\subsection{Графическое задание регулярного выражения}
Регулярное выражение можно задать с помощью графа, где есть сток и исток
\end{document}
